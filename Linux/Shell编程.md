# Linux操作系统

Linux系统的组成：Linux系统内核， 系统级应用程序。



## linux目录结构

- 🚩bin : 是binary的缩写，主要存放一些常用的命令，比如Is、cp、mv之类的。
- boot : 主要存放一些linux启动时需要用到的核心文件。
- 🚩dev : 是device的缩写，主要存放一些linux设备文件。
- 🚩etc : 主要存放系统用户所需要的配置文件和子目录。
- 🚩home : 存放用户目录。
- 🚩lib : 是library的缩写，主要存放一些动态库，供应用程序调用。
- lost + found : 一般是空的，当系统非法关机后，相关文件会存放在此目录。
- 🚩media :  自动挂一些linux系统自动识别的设备，比如U盘，光驱等。
- 🚩mnt : 提供给用户的用于挂载临时别的文件系统（手动挂载），比如另外的硬盘等。
- opt : 提供给主机额外安装软件所需要的目录。
- proc :  这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。
- 🚩root : 超级用户的主目录。
- sbin : s是super user的简称，此目录主要存放一些系统管理员所用到的系统管理程序。
- srv : 主要存放一些系统服务启动之后所要用到的数据。
- run : 主要存放一些系统运行时需要用到的一些文件。
- 🚩usr :  主要存放一些用户的应用程序及文件，类似于windows 下的program files。
  - bin : 存放系统用户所使用的应用程序。
  - sbin : 存放超级用户所使用的高级程序及系统守护程序。
  - src : 内核源代码默认的放置目录。

- tmp : 存放一些临时文件。
- var : 主要存放一些经常被修改的文件，比如日志文件，电子邮件等。

## 终端快捷键

向光标后移动 : `ctrl + f`

向光标前移动 : `ctrl + b`

光标移动到行首 : `ctrl + a`

光标移动到行尾 : `ctrl + e`

向上翻页 : `ctrl + p`

向下翻页 : `ctrl + n`

删除光标前一个字符 : `ctrl + h`

删除光标所在字符 : `ctrl + d`

删除光标前的所有内容 : `ctrl + u`

删除光标和光标末尾的所有内容 : `ctrl + k`

删除光标前的单词 : `ctrl + w`

粘贴ctrl + u、ctrl + k、ctrl + w 删除的内容: `ctrl + y`



## Linux命令

### 帮助命令

#### man

`man` 命令用于在 Linux 系统上查看手册页。

```shell
man [选项] [命令名称]

man man # 查看 man 命令本身的手册页

选项
 		-f # 显示给定关键字的简短描述信息(man [文档章节] [命令名称])
 		-k # 根据关键词搜索帮助手册
 		-w # 先是手册所在位置
 		
操作
		j # 向下移动一行
		k # 向上移动一行
		f # 向下翻一页
		b # 向上翻一页

		/ # 搜索文本
		n # 跳转下一个关键字
		N # 跳转上一个关键字

```

#### info

`info` 命令用于阅读info格式的文件。

```shell
info [选项] [命令名称]

选项
		-w # 显示info文档的物理位
		
操作
		n # 显示下一节点的页面内容
		p # 先是上一节点的页面内容
		l # 返回上一个访问节点的内容

		space # 向前滚动一页
		back  # 向后滚动一页
		b/e   # 一个节点内容的开始/结束
```

#### whatis

`whatis` 命令用于查询一个命令执行什么功能，并将查询结果打印到终端上。

```shell
whatis [命令名称]
```



### 创建新文件和修改时间戳命令

#### touch

`touch` 命令有两个功能：1.改变已有文件的时间戳属性；2.创建新的空文件；

```shell
touch [选项] [文件名称] ... [文件名称]

touch [选项] [修改时间] [文件名称]

选项
		-c # 不创建新文件
		
	 	-a # 改变文件的读取时间记录
	 	-m # 改变文件的修改时间记录
	 	-r # 使用参考文件的记录时间	(touch [文件名称] -r [参考文件名称])

		-d # 修改文件时间为明天	(touch -d "tomorrow" [文件名称])
		-t # 修改文件时间为任意时间	(touch -t CCYYMMDDhhmm.ss [文件名称])
```



### 目录创建命令

#### mkdir

`mkdir` 命令用于创建目录(默认状态下，创建的目录已存在则不创建，新建的目录与它所在的目录下有重名的文件也不行)。

```shell
mkdir [选项] [文件夹名称] ... [文件夹名称]

选项
		-p # 递归创建多级目录
		-m # 建立目录的同时设置目录的权限
		-v # 创建过程
		
示例
		mkdir dir{1..2}
```



### 删除命令

#### rm

`rm` 命令用于删除文件或目录。

```shell
rm [选项] [文件名称]

选项
		-r # 递归删除
		-f # 忽略不存在的文, 不会出现警告信息
		
		-i # 删除前会询问用户是否操作
		-v # 先是指令的详细执行过程
```

#### rmdir

`rmdir` 命令用于删除空目录。

```shell
rmdir [选项] [文件夹名称]

选项
		-p # 递归方式删除指定的目录中所有父级目录，非空则报错
		-v # 显示命令的详细执行过程
```

### 移动或重命名命令

#### mv

`mv` 命令有两个功能：1.移动文件；2重命名文件；

```shell
mv [选项] [源文件] [目标文件夹]

mv [选项] [源文件名称] [新文件名称]

选项
		 -i # 存在同名文件时询问用户是否覆盖
		 -f # 覆盖已有的文件
		 -b # 当文件存在时，覆盖前为其创建一个备份
		 -u # 当源文件比目标文件新时，或者目标文件不存在时，才能执行移动操作
```

### 复制命令

#### CP

`cp`命令用于复制文件或目录

```shell
cp [选项] [源文件名称] [新文件名称]

选项
		-r # 递归复制文件和目录
		-f # 若文件存在，则直接覆盖（默认添加 -f）
		-i # 若文件存在，询问是否覆盖
		-b # 覆盖已存在的文件目标前将目标文件备份
		-a # 在复制目录时使用它保留链接、文件属性、并复制目录下的所有内容
		-v # 详细显示cp命令执行的操作过程
```



### 目录操作

#### cd

`cd`命令

```

```



# Shell 脚本

`#!` 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种shell。

`echo` 命令用于向窗口输出文本。



## 运行shell脚本的两种方法

1.作为可执行程序

```shell
chmod +x demo1.sh

./test.sh
```

2.作为解释器参数

```
/bin/sh demo1.sh
```



## shell变量

### 定义

```sh
variable_name="variable_name_value"
```

⚠️变量名和等号之间不能有空格

⚠️不能使用bash里的关键字(可用help命令查看保留关键字)

### 使用变量

是用一个定义过的变量，只要在变量名前面加美元符号即可。

```sh
variable_name="xxx"

#花括号可选的，目的是帮助解释器识别变量的边界
echo $variable_name
echo ${variable_name}
```

已经定义的变量可以重新被定义。

```sh
variable_name="abc"
echo $variable_name
variable_name="def"
echo $variable_name
```

### 只读变量

使用 `readonly` 命令可以将变量定义为只读变量，只读变量的值是不能被改变的。

```sh
variable_name="abc"
readonly variable_name
```

### 删除变量

使用 `unset` 命令可以删除变量，变量删除后不能被使用，unset命令不能删除只读变量。

```sh
variable_name="abc"
unset variable_name
```

### 变量类型

运行shell时，会同事存在三种变量：

1.`局部变量` 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。

2.`环境变量` 所有的程序包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证才能正常的运行。

3.`shell变量` shell变量是由shell程序设置的特殊变量，shell变量有一部分是环境变量，有一部分是局部变量。



## shell字符串

在shell编程中字符串可以用单引号也可以用双引号，也可以不用引号。

### 单引号

```sh
str='this is a string'
```

单引号字符串的限制：

- 单引号中的任何字符都会原样输出。

- 单引号字符串中的变量是无效的。

- 单引号字符中不能出现单独一个的单引号（对单引号使用转义字符后也不行），但可成对出现，作为字符串拼接使用。

### 双引号

```sh
v="string"
str="Hello \"${v}\"! \n"
echo -e $str	# -e选项使echo能够解释字符串中的转义字符
```

双引号的优点：

- 双引号里可以有变量
- 双引号里可以出现转义字符

### 拼接字符串

```sh
your_name="runoob"
# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1

# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
```

结果：

```
hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !
```

### 获取字符串长度

```sh
string="abcd"
echo ${#string}   # 输出 4
```

变量为字符串时，`${#string}` 等价于 `${#string[0]}`:

```sh
string="abcd"
echo ${#string[0]}   # 输出 4
```

### 字符串提取

```sh
string="abcdefg"
echo ${string:1:4} # 输出 bcde ⚠️第一个字符的索引值为 0
```

### 查找子字符串

查找字符 `i ` 或 `o` 的位置(哪个字母先出现就计算哪个)

```sh
string="runoob is a great site"
echo $(expr index "$string" io) # $()用于执行命令替换，将命令的输出结果嵌入到命令行中
```



## shell数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小

### 定义数组

在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为：

```sh
array_name=(v1 v2 ... n)
```

还可以定义数组的各个分量,可以不使用连续的下标，而且下标的范围没有限制：

```sh
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
```

### 读取数组

读取数组元素值的一般格式是：

```sh
value=${array_name[n]}
```

使用 **@** 符号可以获取数组中的所有元素，例如：

```sh
echo ${array_name[@]}
```

### 获取数组的长度

获取数组长度的方法：

```sh
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
length=${#array_name[n]}
```

### 关联数组

Bash 支持关联数组，可以使用任意的字符串、或者整数作为下标来访问数组元素。

关联数组使用  `declare` 命令来声明，关联数组的键是唯一的

```sh
declare -A array_name		# -A 选项就是用于声明一个关联数组
```

```sh
declare -A site
site["google"]="www.google.com"
site["baidu"]="www.runoob.com"
site["taobao"]="www.taobao.com"
```



## shell 注释

以 `#` 开头的行就是注释，会被解释器忽略

```sh
#--------------------------------------------
# 注释
#--------------------------------------------

##########  开始  ##########
#
##########  结束  ##########
```

### 多行注释

使用 Here 文档

```sh
:<<EOF
	注释内容...
	注释内容...
	注释内容...
EOF
```

使用 `COMMENT` 指定了一个标记（可以是任何标识符，这里使用的是 `COMMENT`），然后直到下一个 `COMMENT` 为止的内容都被当作注释。

```
<<COMMENT
	注释内容...
	注释内容...
	注释内容...
COMMENT
```



使用 `:` 命令

```sh
: '
	注释内容...
	注释内容...
	注释内容...
'
```



## shell传递参数

在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：`$n`。n代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数。

```sh
echo "Shell 传递参数实例！";
echo "执行的文件名：$0"; # $0 代表执行的文件名
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";
```

特殊字符用来处理参数

| $#   | 传递到脚本的参数个数                                         |
| ---- | ------------------------------------------------------------ |
| $*   | 以一个单字符串显示所有向脚本传递的参数。 如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。 |
| $$   | 脚本运行的当前进程ID号                                       |
| $!   | 后台运行的最后一个进程的ID号                                 |
| $@   | 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 |
| $-   | 显示Shell使用的当前选项，与[set命令](https://www.runoob.com/linux/linux-comm-set.html)功能相同。 |
| $?   | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |



## Shell 基本运算符

- 算数运算符
- 关系运算符
- 布尔运算符
- 字符串运算符
- 文件测试运算符

原生bash不支持简单的数学运算，但是可以通过 `awk` 和 `expr` 实现。

`expr` 是一款表达式计算工具，使用它能完成表达式的求值操作，两个数相加(**注意使用的是反引号 ` 而不是单引号 '):

```sh
#!/bin/bash

val=`expr 2 + 2`
echo "两数之和为 : $val"
```

⚠️表达式和运算符之间要有空格。

⚠️完整的表达式要被 ``(反引号) 包含。

### 算术运算符

下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                          | 举例                          |
| :----- | :-------------------------------------------- | :---------------------------- |
| +      | 加法                                          | `expr $a + $b` 结果为 30。    |
| -      | 减法                                          | `expr $a - $b` 结果为 -10。   |
| *      | 乘法                                          | `expr $a \* $b` 结果为  200。 |
| /      | 除法                                          | `expr $b / $a` 结果为 2。     |
| %      | 取余                                          | `expr $b % $a` 结果为 0。     |
| =      | 赋值                                          | a=$b 把变量 b 的值赋给 a。    |
| ==     | 相等。用于比较两个数字，相同则返回 true。     | [ $a == $b ] 返回 false。     |
| !=     | 不相等。用于比较两个数字，不相同则返回 true。 | [ $a != $b ] 返回 true。      |

⚠️条件表达式要放在方括号内，并且要有空格，例如: **[$a==$b]** 是错误的，必须写成 **[ $a == $b ]**。	

### 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

| 运算符 | 说明                                                  | 举例                       |
| ------ | ----------------------------------------------------- | -------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] 返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] 返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] 返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] 返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] 返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] 返回 true。  |

### 布尔运算符

| 运算符 | 说明                                                | 举例                                     |
| :----- | :-------------------------------------------------- | :--------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |

### 逻辑运算符

| 运算符 | 说明       | 举例                                       |
| :----- | :--------- | :----------------------------------------- |
| &&     | 逻辑的 AND | [[ $a -lt 100 && $b -gt 100 ]] 返回 false  |
| \|\|   | 逻辑的 OR  | [[ $a -lt 100 \|\| $b -gt 100 ]] 返回 true |

### 字符串运算符

| 运算符 | 说明                                         | 举例                     |
| :----- | :------------------------------------------- | :----------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | [ $a = $b ] 返回 false。 |
| !=     | 检测两个字符串是否不相等，不相等返回 true。  | [ $a != $b ] 返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | [ -z $a ] 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | [ -n "$a" ] 返回 true。  |
| $      | 检测字符串是否不为空，不为空返回 true。      | [ $a ] 返回 true。       |

### 文件测试运算符

| 操作符  | 说明                                                         | 举例                      |
| :------ | :----------------------------------------------------------- | :------------------------ |
| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 |
| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 |
| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  |
| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 |
| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 |
| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |
| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |
| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |
| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |



## echo命令

Shell 的 echo 指令是用于字符串的输出。

格式：

```sh
echo string	# 字符串后边双引号可以省略
```

### read 命令

read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量。



## printf 命令

格式：

```sh
printf  format-string  [arguments...]	# printf 不会自动换行
```

- **format-string:** 为格式控制字符串
- **arguments:** 为参数列表。

```sh
#!/bin/bash
 
printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg  
printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234
printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543
printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876
```

**%s %c %d %f** 都是格式替代符，**％s** 输出一个字符串，**％d** 整型输出，**％c** 输出一个字符，**％f** 输出实数，以小数形式输出。

**%-10s** 指一个宽度为 10 个字符（**-** 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。

**%-4.2f** 指格式化为小数，其中 **.2** 指保留2位小数。



## test 命令

Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。

### 数值测试

| 参数 | 说明           |
| :--- | :------------- |
| -eq  | 等于则为真     |
| -ne  | 不等于则为真   |
| -gt  | 大于则为真     |
| -ge  | 大于等于则为真 |
| -lt  | 小于则为真     |
| -le  | 小于等于则为真 |

```sh
num1=100
num2=100
if test $[num1] -eq $[num2]
then
    echo '两个数相等！'
else
    echo '两个数不相等！'
fi
```

代码中的 **[]** 执行基本的算数运算

```sh
#!/bin/bash

a=5
b=6

result=$[a+b] # 注意等号两边不能有空格
echo "result 为： $result"
```

### 字符串测试

| =         | 等于则为真               |
| --------- | ------------------------ |
| !=        | 不相等则为真             |
| -z 字符串 | 字符串的长度为零则为真   |
| -n 字符串 | 字符串的长度不为零则为真 |

```sh
num1="ru1noob"
num2="runoob"
if test $num1 = $num2
then
    echo '两个字符串相等!'
else
    echo '两个字符串不相等!'
fi
```

### 文件测试

| -e 文件名 | 如果文件存在则为真                   |
| --------- | ------------------------------------ |
| -r 文件名 | 如果文件存在且可读则为真             |
| -w 文件名 | 如果文件存在且可写则为真             |
| -x 文件名 | 如果文件存在且可执行则为真           |
| -s 文件名 | 如果文件存在且至少有一个字符则为真   |
| -d 文件名 | 如果文件存在且为目录则为真           |
| -f 文件名 | 如果文件存在且为普通文件则为真       |
| -c 文件名 | 如果文件存在且为字符型特殊文件则为真 |
| -b 文件名 | 如果文件存在且为块特殊文件则为真     |

```sh
cd /bin
if test -e ./bash
then
    echo '文件已存在!'
else
    echo '文件不存在!'
fi
```

另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： **!** 最高， **-a** 次之， **-o** 最低。

```sh
cd /bin
if test -e ./notFile -o -e ./bash
then
    echo '至少有一个文件存在!'
else
    echo '两个文件都不存在'
fi
```



## Shell 流程控制

sh 的流程控制不可为空，在 sh/bash 里可不能这么写，如果 else 分支没有语句执行，就不要写这个 else。

`[...]` 判断语句中大于使用 `-gt`，小于使用 `-lt`

`((...))` 作为判断语句，大于和小于可以直接使用 `>` 和 `<`

### if else

格式：

```sh
if condition
then
    command1 
    command2
    ...
    commandN 
fi
```

可以写成一行（适用于终端命令提示符）

```sh
if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi
```

### if else-if else

格式：

```sh
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
```

### for 循环

格式：

```sh
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
```

### while 语句

格式：

```sh
while condition
do
    command
done

```

while循环可用于读取键盘信息，按<Ctrl-D>结束循环

```sh
echo '按下 <CTRL-D> 退出'
echo -n '输入你最喜欢的网站名: '
while read FILM
do
    echo "是的！$FILM 是一个好网站"
done
```

#### 无限循环

格式：

```sh
while :
do
    command
done
```

### ntil 循环

until 循环执行一系列命令直至条件为 true 时停止。一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。

格式:

```sh
until condition
do
    command
done

```

### case ... esac

一种多分支选择结构，每个 case 分支用右圆括号开始，用两个分号 **;;** 表示执行结束，跳出整个 case ... esac 语句，esac作为结束标记。

⚠️如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。

```sh
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2)
    command1
    command2
    ...
    commandN
    ;;
esac

```

### 跳出循环

`break` 命令允许跳出所有循环（终止执行后面的所有循环）

`continue` 命令与 break 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。



## Shell 函数

格式：

```sh
[ function ] funname [()]

{

    action;

    [return int;]

}
```

- 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
- 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)

示例：

```sh
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

demoFun(){
    echo "这是我的第一个 shell 函数!"
}
echo "-----函数开始执行-----"
demoFun
echo "-----函数执行完毕-----"
```

带有return语句的函数

```sh
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

funWithReturn(){
    echo "这个函数会对输入的两个数字进行相加运算..."
    echo "输入第一个数字: "
    read aNum
    echo "输入第二个数字: "
    read anotherNum
    echo "两个数字分别为 $aNum 和 $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "输入的两个数字之和为 $? !"
```

函数返回值在调用该函数后通过 $? 来获得。

注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。

### 函数参数

在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...

```sh
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
```

注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。

另外，还有几个特殊字符用来处理参数：

| $#   | 传递到脚本或函数的参数个数                                   |
| ---- | ------------------------------------------------------------ |
| $*   | 以一个单字符串显示所有向脚本传递的参数                       |
| $$   | 脚本运行的当前进程ID号                                       |
| $!   | 后台运行的最后一个进程的ID号                                 |
| $@   | 与$*相同，但是使用时加引号，并在引号中返回每个参数。         |
| $-   | 显示Shell使用的当前选项，与set命令功能相同。                 |
| $?   | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |



## Shell 输入/输出重定向

大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。

重定向命令列表如下：

| command > file  | 将输出重定向到 file。                              |
| --------------- | -------------------------------------------------- |
| command < file  | 将输入重定向到 file。                              |
| command >> file | 将输出以追加的方式重定向到 file。                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m          | 将输出文件 m 和 n 合并。                           |
| n <& m          | 将输入文件 m 和 n 合并。                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |

### 输出重定向

```sh
command > file	# 将完整的输出重定向到 file
```

⚠️任何file内的已经存在的内容将被新内容替代。



### 输入重定向

```sh
command < file
```

示例：

```sh
wc -l < infile > outfile	# 执行command，从文件infile读取内容，然后将输出写入到outfile中
```



一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：

- 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。
- 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。
- 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。



默认情况下，command > file 将 stdout 重定向到 file，command < file 将stdin 重定向到 file。

```sh
command 2> file	# 将stderr输出到file
```

```sh
command > file 2>&1	# 将 stdout 和 stderr 合并后重定向到 file
```

⚠️这里的 `2` 和 `>` 之间不可以有空格，`2>` 是一体的时候才表示错误输出。



### /dev/null 文件

如果希望执行某个命令，但不希望在屏幕上显示输出结果：

```sh
command > /dev/null	# 将输出重定向到 /dev/null
```

⚠️/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。



## Shell 文件包含

Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。

```sh
. filename   # 注意点号(.)和文件名中间有一空格

或

source filename
```

⚠️被包含的文件 test1.sh 不需要可执行权限。



-z 表示检查变量是否为空(长度是0)；

-d 表示检查指定的路径是否存在并且是一个目录；

-v 选取不包含指定字符串；





## vim

复制当前行：`yy` 

复制多行：`选中多行 + y`

粘贴： `p` 粘贴到光标下， `P`粘贴到光标前

删除当前行：`dd` 

删除：`选中文本 + d`

撤销：`u`

恢复撤销： `ctrl + r`

向前移动到下一个单词的开头：`w`

向后移动到前一个单词的开头：`b`

向前移动到下一个单词的末尾：`e`



### 正常模式

删除光标位置字符：`x`

在当前行下方插入：`o`

在当前行末尾插入：`A`

删除光标前的内容：`d0`

移动到行首：`0`

移动到行尾：`$`



